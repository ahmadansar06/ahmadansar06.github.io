<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge"><title> - 你好！Hello！Hallo！Bonjour！</title><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
	<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
	<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
	<link rel="manifest" href="/site.webmanifest">

	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta itemprop="name" content="">
<meta itemprop="description" content="my_randsvd() The MATLAB builtin function gallery(&#39;randsvd&#39;) can only generate random matrix or symmetric positive definite matrix.
However, usually we need to test our algorithms for symmetric matrix. Although you can get symmetric matrix by A = randn(n); A = A &#43; A&#39;;, it would be nice to inherit the features from gallery(&#39;randsvd&#39;), such as control the singular values distributions.
The following code achieves such desire by artificially introducing negative signs into the eigenvalues of the symmetric positive definite matrix generated by gallery(&#39;randsvd&#39;).">

<meta itemprop="wordCount" content="711">
<meta itemprop="keywords" content="" /><meta property="og:title" content="" />
<meta property="og:description" content="my_randsvd() The MATLAB builtin function gallery(&#39;randsvd&#39;) can only generate random matrix or symmetric positive definite matrix.
However, usually we need to test our algorithms for symmetric matrix. Although you can get symmetric matrix by A = randn(n); A = A &#43; A&#39;;, it would be nice to inherit the features from gallery(&#39;randsvd&#39;), such as control the singular values distributions.
The following code achieves such desire by artificially introducing negative signs into the eigenvalues of the symmetric positive definite matrix generated by gallery(&#39;randsvd&#39;)." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhengbo0503.github.io/pages/my_randsvd/" /><meta property="article:section" content="pages" />


<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content=""/>
<meta name="twitter:description" content="my_randsvd() The MATLAB builtin function gallery(&#39;randsvd&#39;) can only generate random matrix or symmetric positive definite matrix.
However, usually we need to test our algorithms for symmetric matrix. Although you can get symmetric matrix by A = randn(n); A = A &#43; A&#39;;, it would be nice to inherit the features from gallery(&#39;randsvd&#39;), such as control the singular values distributions.
The following code achieves such desire by artificially introducing negative signs into the eigenvalues of the symmetric positive definite matrix generated by gallery(&#39;randsvd&#39;)."/>
<link href='https://fonts.googleapis.com/css?family=Playfair+Display:700' rel='stylesheet' type='text/css'>
	<link rel="stylesheet" type="text/css" media="screen" href="https://zhengbo0503.github.io/css/normalize.css" />
	<link rel="stylesheet" type="text/css" media="screen" href="https://zhengbo0503.github.io/css/main.css" />

        <link id="dark-scheme" rel="stylesheet" type="text/css" href="https://zhengbo0503.github.io/css/dark.css" />

	
		<script src="https://zhengbo0503.github.io/js/main.js"></script>
	
</head>



<body>
	<div class="container wrapper">
		<div class="header">
	
	<h1 class="site-title"><a href="https://zhengbo0503.github.io/">你好！Hello！Hallo！Bonjour！</a></h1>
	<div class="site-description"><p>Good Good Study, Day Day Up</p><nav class="nav social">
			<ul class="flat"></ul>
		</nav>
	</div>

	<nav class="nav">
		<ul class="flat">
			
		</ul>
	</nav>
</div>


		<div class="post">
			<div class="post-header">
				
				<div class="matter">
					<h1 class="title"></h1>
					
				</div>
			</div>
					
			<div>
				
			</div>
			<div class="markdown">
				<h2 id="my_randsvd"><code>my_randsvd()</code></h2>
<p>The MATLAB builtin function <code>gallery('randsvd')</code> can only generate random matrix
or symmetric positive definite matrix.<br>
However, usually we need to test our algorithms
for symmetric matrix. Although you can get symmetric matrix by
<code>A = randn(n); A = A + A';</code>, it would be nice to inherit the features from
<code>gallery('randsvd')</code>, such as control the singular values distributions.<br>
The following code achieves such desire by artificially introducing
negative signs into the eigenvalues of the symmetric positive definite
matrix generated by <code>gallery('randsvd')</code>.<br>
In addtion, the function returns the eigenvalues of your random, symmetric,
real matrix for you. Such that you can test your eigen-solvers!</p>
<ul>
<li>version: 14 Oct 2023.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-matlab" data-lang="matlab"><span style="display:flex;"><span><span style="color:#00f">function</span> [A,evals] = my_randsvd(n, kappa, mode)
</span></span><span style="display:flex;"><span><span style="color:#008000">%MY_RANDSVD Customized gallery(&#39;randsvd&#39;)</span>
</span></span><span style="display:flex;"><span><span style="color:#008000">%  [A, EVALS] = my_randsvd(N, KAPPA, MODE) generates</span>
</span></span><span style="display:flex;"><span><span style="color:#008000">%  a random symmetric matrix A of order N with cond(A) = KAPPA</span>
</span></span><span style="display:flex;"><span><span style="color:#008000">%  and singular values from distribution MODE, and </span>
</span></span><span style="display:flex;"><span><span style="color:#008000">%  the eigenvalues of A, EVALS, at double precision. </span>
</span></span><span style="display:flex;"><span><span style="color:#008000">%</span>
</span></span><span style="display:flex;"><span><span style="color:#008000">% Input :</span>
</span></span><span style="display:flex;"><span><span style="color:#008000">%      N : Size of the matrix.</span>
</span></span><span style="display:flex;"><span><span style="color:#008000">%  </span>
</span></span><span style="display:flex;"><span><span style="color:#008000">%  KAPPA : pre-defined 2-norm condition number for the output,</span>
</span></span><span style="display:flex;"><span><span style="color:#008000">%          if kappa is negative, it will return a symmetric</span>
</span></span><span style="display:flex;"><span><span style="color:#008000">%          positive definite matrix.</span>
</span></span><span style="display:flex;"><span><span style="color:#008000">%		   Default value is 100.</span>
</span></span><span style="display:flex;"><span><span style="color:#008000">%  </span>
</span></span><span style="display:flex;"><span><span style="color:#008000">%   MODE : one of the following values:</span>
</span></span><span style="display:flex;"><span><span style="color:#008000">%	       1: one large singular value,</span>
</span></span><span style="display:flex;"><span><span style="color:#008000">%		   2: one small singular value,</span>
</span></span><span style="display:flex;"><span><span style="color:#008000">%		   3: geometrically distributed singular values,</span>
</span></span><span style="display:flex;"><span><span style="color:#008000">%		   4: arithmetically distributed singular values,</span>
</span></span><span style="display:flex;"><span><span style="color:#008000">%		   5: random singular values with uniformly distributed</span>
</span></span><span style="display:flex;"><span><span style="color:#008000">%		      logarithm.</span>
</span></span><span style="display:flex;"><span><span style="color:#008000">%          Default value is 3. </span>
</span></span><span style="display:flex;"><span><span style="color:#008000">%</span>
</span></span><span style="display:flex;"><span><span style="color:#008000">% Reference:</span>
</span></span><span style="display:flex;"><span><span style="color:#008000">% The MATLAB &#39;gallery&#39; function.</span>
</span></span><span style="display:flex;"><span><span style="color:#008000">% https://www.mathworks.com/help/matlab/ref/gallery.html </span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>classname = <span style="color:#a31515">&#39;double&#39;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">switch</span> nargin
</span></span><span style="display:flex;"><span>	<span style="color:#00f">case</span> 1
</span></span><span style="display:flex;"><span>		kappa = 100;
</span></span><span style="display:flex;"><span>		mode = 3;
</span></span><span style="display:flex;"><span>	<span style="color:#00f">case</span> 2
</span></span><span style="display:flex;"><span>		mode = 3;
</span></span><span style="display:flex;"><span><span style="color:#00f">end</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#008000">% check if we need export p.d. matrix</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">if</span> sign(kappa) == 1, pd = false; <span style="color:#00f">else</span>, pd = true; <span style="color:#00f">end</span>
</span></span><span style="display:flex;"><span>kappa = abs(kappa);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">switch</span> mode <span style="color:#008000">% Set up vector of singular values</span>
</span></span><span style="display:flex;"><span>	<span style="color:#00f">case</span> 1
</span></span><span style="display:flex;"><span>		sigma = ones(n,1)./kappa;
</span></span><span style="display:flex;"><span>		sigma(1) = 1;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#00f">case</span> 2
</span></span><span style="display:flex;"><span>		sigma = ones(n,1);
</span></span><span style="display:flex;"><span>		sigma(n) = 1/kappa;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#00f">case</span> 3
</span></span><span style="display:flex;"><span>		factor = kappa^(-1/(n-1));
</span></span><span style="display:flex;"><span>		sigma = factor.^(0:n-1);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#00f">case</span> 4
</span></span><span style="display:flex;"><span>		sigma = ones(n,1) - (0:n-1)&#39;/(n-1)*(1-1/kappa);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#00f">case</span> 5    <span style="color:#008000">% In this case cond(A) &lt;= kappa.</span>
</span></span><span style="display:flex;"><span>		sigma = exp( -rand(n,1)*log(kappa) );
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#00f">otherwise</span>
</span></span><span style="display:flex;"><span>		error(message(<span style="color:#a31515">&#39;MATLAB:randsvd:invalidMode&#39;</span>));
</span></span><span style="display:flex;"><span><span style="color:#00f">end</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>sigma = cast(sigma,classname);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">if</span> ~pd <span style="color:#008000">% randomly introducing signs</span>
</span></span><span style="display:flex;"><span>	[l,j] = size(sigma(2:n-1));
</span></span><span style="display:flex;"><span>	signs = sign(rand(1,n-2)*2-1)&#39;;
</span></span><span style="display:flex;"><span>	signs = reshape(signs,[l,j]);
</span></span><span style="display:flex;"><span>	sigma(2:n-1) = sigma(2:n-1) .* signs;
</span></span><span style="display:flex;"><span><span style="color:#00f">end</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Q = qmult(n,1,classname);
</span></span><span style="display:flex;"><span>A = Q*diag(sigma)*Q&#39;;
</span></span><span style="display:flex;"><span>A = (A + A&#39;)/2; <span style="color:#008000">% ensure symmetry</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#008000">% output true eigenvalues/singular values</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">if</span> nargout == 2
</span></span><span style="display:flex;"><span>    evals = sigma&#39;;
</span></span><span style="display:flex;"><span><span style="color:#00f">end</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">end</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#008000">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
</span></span><span style="display:flex;"><span><span style="color:#008000">% The function above rely on the following function</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">function</span> B = qmult(A,method,classname)
</span></span><span style="display:flex;"><span><span style="color:#008000">%QMULT Pre-multiply matrix by random orthogonal matrix.</span>
</span></span><span style="display:flex;"><span><span style="color:#008000">%   QMULT(A) returns Q*A where Q is a random real orthogonal matrix</span>
</span></span><span style="display:flex;"><span><span style="color:#008000">%   from the Haar distribution of dimension the number of rows in A.</span>
</span></span><span style="display:flex;"><span><span style="color:#008000">%   Special case: if A is a scalar then QMULT(A) is the same as QMULT(EYE(A)).</span>
</span></span><span style="display:flex;"><span><span style="color:#008000">%   QMULT(A,METHOD) specifies how the computations are carried out.</span>
</span></span><span style="display:flex;"><span><span style="color:#008000">%   METHOD = 0 is the default, while METHOD = 1 uses a call to QR,</span>
</span></span><span style="display:flex;"><span><span style="color:#008000">%   which is much faster for large dimensions, even though it uses more flops.</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#008000">%   Called by RANDCOLU, RANDCORR, RANDJORTH, RANDSVD.</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#008000">%   Reference:</span>
</span></span><span style="display:flex;"><span><span style="color:#008000">%   G. W. Stewart, The efficient generation of random</span>
</span></span><span style="display:flex;"><span><span style="color:#008000">%   orthogonal matrices with an application to condition estimators,</span>
</span></span><span style="display:flex;"><span><span style="color:#008000">%   SIAM J. Numer. Anal., 17 (1980), 403-409.</span>
</span></span><span style="display:flex;"><span><span style="color:#008000">%</span>
</span></span><span style="display:flex;"><span><span style="color:#008000">%   Nicholas J. Higham</span>
</span></span><span style="display:flex;"><span><span style="color:#008000">%   Copyright 1984-2020 The MathWorks, Inc.</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">if</span> nargin &lt; 2 || isempty(method)
</span></span><span style="display:flex;"><span>	method = 0;
</span></span><span style="display:flex;"><span><span style="color:#00f">end</span>
</span></span><span style="display:flex;"><span><span style="color:#008000">%  Handle scalar A.</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">if</span> isscalar(A)
</span></span><span style="display:flex;"><span>	n = A;
</span></span><span style="display:flex;"><span>	A = eye(n,classname);
</span></span><span style="display:flex;"><span><span style="color:#00f">else</span>
</span></span><span style="display:flex;"><span>	n = size(A, 1);
</span></span><span style="display:flex;"><span><span style="color:#00f">end</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">if</span> isempty(A) <span style="color:#008000">% nothing to do.</span>
</span></span><span style="display:flex;"><span>	B = A;
</span></span><span style="display:flex;"><span>	<span style="color:#00f">return</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">end</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">if</span> method == 1
</span></span><span style="display:flex;"><span>	[Q,R] = qr(randn(n));
</span></span><span style="display:flex;"><span>	B = Q*diag(sign(diag(R)))*A;
</span></span><span style="display:flex;"><span>	<span style="color:#00f">return</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">end</span>
</span></span><span style="display:flex;"><span>d = zeros(n,1,classname);
</span></span><span style="display:flex;"><span><span style="color:#00f">for</span> k = n-1:-1:1
</span></span><span style="display:flex;"><span>	<span style="color:#008000">% Generate random Householder transformation.</span>
</span></span><span style="display:flex;"><span>	x = randn(n-k+1,1);
</span></span><span style="display:flex;"><span>	s = norm(x);
</span></span><span style="display:flex;"><span>	sgn = mysign(x(1));
</span></span><span style="display:flex;"><span>	s = sgn*s;
</span></span><span style="display:flex;"><span>	d(k) = -sgn;
</span></span><span style="display:flex;"><span>	x(1) = x(1) + s;
</span></span><span style="display:flex;"><span>	beta = s*x(1);
</span></span><span style="display:flex;"><span>	<span style="color:#008000">% Apply the transformation to A.</span>
</span></span><span style="display:flex;"><span>	y = x&#39;*A(k:n,:);
</span></span><span style="display:flex;"><span>	A(k:n,:) = A(k:n,:) - x*(y/beta);
</span></span><span style="display:flex;"><span><span style="color:#00f">end</span>
</span></span><span style="display:flex;"><span><span style="color:#008000">% Tidy up signs.</span>
</span></span><span style="display:flex;"><span><span style="color:#00f">for</span> i=1:n-1
</span></span><span style="display:flex;"><span>	A(i,:) = d(i)*A(i,:);
</span></span><span style="display:flex;"><span><span style="color:#00f">end</span>
</span></span><span style="display:flex;"><span>A(n,:) = A(n,:)*mysign(randn);
</span></span><span style="display:flex;"><span>B = A;
</span></span><span style="display:flex;"><span><span style="color:#00f">end</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#00f">function</span> S = mysign(A)
</span></span><span style="display:flex;"><span><span style="color:#008000">%MYSIGN True sign function with MYSIGN(0) = 1.</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#008000">%   Called by various matrices in elmat/private.</span>
</span></span><span style="display:flex;"><span><span style="color:#008000">%</span>
</span></span><span style="display:flex;"><span><span style="color:#008000">%   Nicholas J. Higham</span>
</span></span><span style="display:flex;"><span><span style="color:#008000">%   Copyright 1984-2013 The MathWorks, Inc.</span>
</span></span><span style="display:flex;"><span>S = sign(A);
</span></span><span style="display:flex;"><span>S(S==0) = 1;
</span></span><span style="display:flex;"><span><span style="color:#00f">end</span>
</span></span></code></pre></div><ul>
<li>Acknowledgement. Professor Nicholas J. Higham.</li>
</ul>

				
			</div>

			<div class="tags">
				
					
				
			</div></div>
	</div>
	<div class="footer wrapper">
	<nav class="nav">
		<div>  Created by Zhengbo</div>
	</nav>
</div>


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-52525161-8', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

</body>
</html>
